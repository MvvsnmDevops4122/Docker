
====================================================================================================================================

                                                        DOCKER VOLUMES

=====================================================================================================================================

ğŸ³ Docker Volumes
-------------------


âœ… Containers are temporary. When they stop or restart, their data is lost. 

âœ… Volumes store data outside the container, keeping it safe even if the container is deleted. 

âœ… Volumes are used to save data created by containers. 

âœ… They help prevent data loss. 

âœ… Volumes make containers stateful, meaning data stays even after restarts.

âœ… We have 2 types of volumes in Docker

   1) Bind Mounts(Host mount):

      By using a bind mount, we can store data in the server's file system. Even if our container crashes, we can still recover the data.

   2) volumes (External volumes)

      (i) local volumes  
      (ii) network volumes [NFS,EBS,S3]


Before Docker Volumes
---------------------

âœ… Earlier, data was stored inside the containerâ€™s file system.  
âœ… If the container crashed or was removed, all data would be lost.  
âœ… To solve this problem, Docker volumes were introduced â€” Volumes store data outside the container, keeping it safe even if the container is deleted. 
    


ğŸ” Revised LAB: Spring Boot + MongoDB (Before docker volumes)
============================================================

âœ… Step 1: Fork the Project
----------------------------

Fork the repo into your GitHub account:  
https://github.com/kkdevopsb5/spring-boot-mongo-docker-kkfunda.git

âœ… Step 2: Clone the Project
----------------------------

git clone https://github.com/kkdevopsb5/spring-boot-mongo-docker-kkfunda.git
cd spring-boot-mongo-docker-kkfunda

âœ… Step 3: Check the Dockerfile
--------------------------------

cat Dockerfile

âœ… Key content:

Dockerfile
# Stage 1: Build the application
FROM maven:3.8.5-openjdk-8-slim AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Run the application
FROM openjdk:8-alpine
ENV PROJECT_HOME=/opt/app
WORKDIR $PROJECT_HOME
COPY --from=build /app/target/spring-boot-mongo-1.0.jar $PROJECT_HOME/spring-boot-mongo.jar
EXPOSE 8080
CMD ["java", "-jar", "./spring-boot-mongo.jar"]
```

âœ… Step 4: Build the Docker Image
----------------------------------

docker build -t springimage .
docker images


âœ… Step 5: Create a Custom Docker Bridge Network
-------------------------------------------------

docker network create jionetwork
docker network ls

âœ… Step 6: Create Spring Boot Application Container
----------------------------------------------------

docker run -d -p 8080:8080 --name springapp --network jionetwork \
-e MONGO_DB_HOSTNAME=mongo \
-e MONGO_DB_USERNAME=devdb \
-e MONGO_DB_PASSWORD=dev@123 \
springimage


> -e = environment variables
> NOTE: Tomcat is not there why we are using -p ? .... In springboot framework by default tomcat is installed.
> NOTE: Default port for Mongo database :27017

âœ… Step 7: Access the Application
-------------------------------------

Open your browser:
http\://<your-ec2-ip>:8080
Example: [http://13.126.86.86:8080](http://13.126.86.86:8080)

ğŸš« Data won't be saved yet since MongoDB isnâ€™t running.

âœ… Step 8: Create MongoDB Container
-----------------------------------

docker run -d --name mongo --network jionetwork \
-e MONGO_INITDB_ROOT_USERNAME=devdb \
-e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
mongo

âœ… Step 9: Check MongoDB for Data
----------------------------------

docker exec -it mongo bash
mongosh --host localhost:27017 -u devdb -p dev@123

show databases;
use users;
db.users.find();


âœ… Step 10: See the Default Location of Mongo
-----------------------------------------------

docker exec mongo ls /data/db

âœ… Step 11: Delete App Container â€” Check If Data Still Exists
--------------------------------------------------------------

docker rm -f springapp

Then:

docker run -d -p 8080:8080 --name springapp --network jionetwork  \
-e MONGO_DB_HOSTNAME=mongo \
-e MONGO_DB_USERNAME=devdb \
-e MONGO_DB_PASSWORD=dev@123 \
springimage

âœ… Proof: MongoDB still holds the data.

âŒ Step 12: Delete the DB (Mongo) Container â€” Check If Data Is Lost
--------------------------------------------------------------------

docker rm -f mongo


Then recreate:

```bash
docker run -d --name mongo --network jionetwork \
-e MONGO_INITDB_ROOT_USERNAME=devdb \
-e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
mongo
```

ğŸ” Why? MongoDB's data was stored inside the container at `/data/db`, and no volume was used.

# ğŸ’¡ PROOF: Why We Need Volumes

## âœ… Step 13: Use Docker Volumes for Persistence

```bash
docker volume create mongovolume
docker volume ls
docker volume inspect mongovolume
```

ğŸ“Œ Check data on host:

```bash
sudo ls /var/lib/docker/volumes/mongovolume/_data
```

ğŸš€ Create MongoDB container with volume:

```bash
docker run -d --name mongo --network jionetwork \
-e MONGO_INITDB_ROOT_USERNAME=devdb \
-e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
-v mongovolume:/data/db \
mongo
```

âœ… Test: Stop & recreate Mongo container. Data persists.

# ğŸ§± What is a Bind Mount?

* Maps a file or directory from the host system to inside the container.
* Use `-v` option

ğŸ”§ Syntax:

```bash
docker run -v /host/path:/container/path ...
```

âœ… Example:

```bash
docker run -d --name mongo --network jionetwork \
-e MONGO_INITDB_ROOT_USERNAME=devdb \
-e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
-v /home/ubuntu/Maven-Web_Application-/B5-projects/spring-boot-mongo-docker-kkfunda/backup:/data/db \
mongo
```

## ğŸ” Steps to Use Bind Mount:

```bash
mkdir -p /home/ubuntu/Maven-Web_Application-/B5-projects/spring-boot-mongo-docker-kkfunda/backup
cd /home/ubuntu/Maven-Web_Application-/B5-projects/spring-boot-mongo-docker-kkfunda/backup

docker run -d --name mongo --network jionetwork \
-e MONGO_INITDB_ROOT_USERNAME=devdb \
-e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
-v /home/ubuntu/Maven-Web_Application-/B5-projects/spring-boot-mongo-docker-kkfunda/backup:/data/db \
mongo
```

âœ… Test: Stop container, restart it with same bind mount â†’ Data persists.

# ğŸ§± Assignment: Run Jenkins in Docker with Volumes and Create a Job

ğŸ”¹ Step 1: Pull Jenkins Docker Image

```bash
docker pull jenkins/jenkins:lts
```

ğŸ”¹ Step 2: Create a Docker Volume for Jenkins Data

```bash
docker volume create jenkins_data
```

ğŸ”¹ Step 3: Run Jenkins Container with Named Volume

```bash
docker run -d -p 8080:8080 --name jenkins \
-v jenkins_data:/var/jenkins_home \
jenkins/jenkins:lts
```

ğŸ”¹ Step 4: Get Jenkins Initial Admin Password

```bash
docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword
```

ğŸ”¹ Step 5: Setup Jenkins via UI

ğŸ”¹ Step 6: Create a Job and Verify Volume Concept

ğŸ”¹ Step 7: Check Volume Persistence

```bash
docker rm -f jenkins

docker run -d -p 8080:8080 --name jenkins \
-v jenkins_data:/var/jenkins_home \
jenkins/jenkins:lts
```

âœ… Job still exists!

# ğŸ’¡ IQ: Why do we use Docker Volumes instead of Bind Mounts?

âœ… Because Docker volumes are centrally managed and easier to back up per container compared to scattered host paths.

# ğŸ§  IQ: How can you migrate Docker from one server to another?

âœ… Full backup:

```bash
sudo tar -czvf docker-backup.tar.gz /var/lib/docker
scp docker-backup.tar.gz user@target-server:/tmp
sudo systemctl stop docker
sudo tar -xzvf /tmp/docker-backup.tar.gz -C /
sudo systemctl start docker
```

# ğŸ“¦ Docker Volume Management

ğŸ” List Volumes:

```bash
docker volume ls
```

âŒ Remove Volumes:

```bash
docker volume prune
docker volume rm <volume_name>
```

ğŸ› ï¸ Create Named Volumes:

```bash
docker volume create -d local jiovolume
docker volume create Airtelvolume
```

ğŸ•µï¸ Inspect a Volume:

```bash
docker volume inspect jiovolume
```

ğŸ—‚ Where are volumes stored?

```bash
sudo ls -lth /var/lib/docker/volumes/
```

ğŸ³ Running Containers With Volumes

```bash
docker run -d --name mongo \
  -v jiovolume:/data/db \
  --network jionetwork \
  -e MONGO_INITDB_ROOT_USERNAME=devdb \
  -e MONGO_INITDB_ROOT_PASSWORD=dev@123 \
  mongo

docker run -d --name springapp \
  --network jionetwork \
  -p 8080:8080 \
  -e MONGO_DB_HOSTNAME=mongo \
  -e MONGO_DB_USERNAME=devdb \
  -e MONGO_DB_PASSWORD=dev@123 \
  springimage
```

âœ… Data Persistence Verification (Interview Scenario)

â“ IQ: Can I map a volume or port to a running container?

âŒ No â€” you cannot attach volumes or expose new ports to a running container.

```

---

Let me know if you want this content exported to a `.md` file (downloadable), or if you'd like me to add a **table of contents**, **badges**, or other enhancements to the README.
```

